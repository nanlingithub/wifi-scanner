"""
WiFiæ¼æ´æ£€æµ‹æ¨¡å—
åŠŸèƒ½ï¼šWPSæ¼æ´ã€Evil Twinã€åŠ å¯†åˆ†æ
ç‰ˆæœ¬ï¼šV2.0 Enhanced (é›†æˆCVEæ•°æ®åº“)
"""

import re
from collections import defaultdict
from typing import Dict, List, Any, Optional

# å¯¼å…¥WPS CVEæ•°æ®åº“
try:
    from .wps_cve_database import WPSCVEDatabase
    HAS_CVE_DB = True
except ImportError:
    HAS_CVE_DB = False


class VulnerabilityDetector:
    """WiFiæ¼æ´æ£€æµ‹å™¨"""
    
    # WPSæ¼æ´å‚å•†æ•°æ®åº“ï¼ˆåŸºäºå…¬å¼€æ¼æ´æŠ¥å‘Šï¼‰
    WPS_VULNERABLE_VENDORS = {
        # PixieDustæ¼æ´ï¼ˆCVE-2017-16898ï¼‰
        'pixiedust': {
            'D-Link', 'TP-Link', 'Netgear', 'Linksys', 'Belkin',
            'ZyXEL', 'ASUS', 'Huawei', 'ZTE', 'Tenda'
        },
        # Reaverå·²çŸ¥æ¼æ´
        'reaver': {
            'Broadcom', 'Ralink', 'Realtek', 'Atheros'
        }
    }
    
    # é»˜è®¤SSIDåˆ—è¡¨ï¼ˆå¯ç–‘APï¼‰
    DEFAULT_SSIDS = {
        'tp-link', 'netgear', 'linksys', 'dlink', 'd-link',
        'asus', 'belkin', 'zyxel', 'huawei', 'zte', 'tenda',
        'default', 'wireless', 'wifi', 'network', 'home',
        'router', 'modem', 'internet', 'speedtouch'
    }
    
    def __init__(self):
        self.known_aps = {}  # ç™½åå•APæ•°æ®åº“ {ssid: [bssid1, bssid2, ...]}
        # åˆå§‹åŒ–WPS CVEæ•°æ®åº“
        if HAS_CVE_DB:
            self.wps_cve_db = WPSCVEDatabase()
        else:
            self.wps_cve_db = None
        
    def check_wps_vulnerability(self, network: Dict[str, Any]) -> Dict[str, Any]:
        """
        æ£€æµ‹WPSæ¼æ´ï¼ˆå¢å¼ºç‰ˆ - é›†æˆCVEæ•°æ®åº“ï¼‰
        
        Args:
            network: ç½‘ç»œä¿¡æ¯å­—å…¸
            
        Returns:
            æ¼æ´æ£€æµ‹ç»“æœ
        """
        result = {
            'wps_enabled': False,
            'vulnerable': False,
            'vulnerability_type': None,
            'severity': 'LOW',
            'exploit_time': None,
            'recommendations': [],
            'cve_list': [],  # æ–°å¢ï¼šç›¸å…³CVEåˆ—è¡¨
            'cvss_score': 0.0  # æ–°å¢ï¼šCVSSè¯„åˆ†
        }
        
        # 1. æ£€æµ‹WPSæ˜¯å¦å¯ç”¨ï¼ˆåŸºäºå¯å‘å¼è§„åˆ™ï¼‰
        auth = network.get('authentication', '').upper()
        vendor = self._get_vendor_from_bssid(network.get('bssid', ''))
        
        # Windows netshæ— æ³•ç›´æ¥æ£€æµ‹WPSï¼Œä½¿ç”¨å¯å‘å¼æ¨æ–­
        # è§„åˆ™ï¼šå¤§éƒ¨åˆ†å®¶ç”¨è·¯ç”±å™¨é»˜è®¤å¯ç”¨WPS
        wps_likely = self._is_wps_likely_enabled(network, vendor)
        
        if wps_likely:
            result['wps_enabled'] = True
            
            # 2. ä½¿ç”¨CVEæ•°æ®åº“æ£€æµ‹ï¼ˆä¼˜å…ˆï¼‰
            if self.wps_cve_db:
                cve_vulns = self.wps_cve_db.get_vulnerabilities_by_vendor(vendor)
                
                if cve_vulns:
                    # ä½¿ç”¨æœ€ä¸¥é‡çš„æ¼æ´
                    most_severe = cve_vulns[0]
                    result['vulnerable'] = True
                    result['vulnerability_type'] = f"{most_severe['name']} ({most_severe['cve_id']})"
                    result['severity'] = most_severe['severity']
                    result['exploit_time'] = most_severe['exploit_time']
                    result['cvss_score'] = most_severe['cvss_score']
                    result['recommendations'] = most_severe['recommendations']
                    
                    # æ·»åŠ æ‰€æœ‰ç›¸å…³CVE
                    result['cve_list'] = [
                        {
                            'cve_id': v['cve_id'],
                            'name': v['name'],
                            'severity': v['severity'],
                            'cvss_score': v['cvss_score'],
                            'patch_available': v['patch_available']
                        }
                        for v in cve_vulns[:5]  # æœ€å¤š5ä¸ª
                    ]
                    
                    return result
            
            # 3. å›é€€åˆ°åŸæœ‰æ£€æµ‹é€»è¾‘ï¼ˆå¦‚æœæ²¡æœ‰CVEæ•°æ®åº“ï¼‰
            # æ£€æµ‹PixieDustæ¼æ´
            if vendor in self.WPS_VULNERABLE_VENDORS['pixiedust']:
                result['vulnerable'] = True
                result['vulnerability_type'] = 'PixieDust (CVE-2017-16898)'
                result['severity'] = 'CRITICAL'
                result['exploit_time'] = '< 5åˆ†é’Ÿ'
                result['cvss_score'] = 9.8
                result['recommendations'].append('ç«‹å³ç¦ç”¨WPSåŠŸèƒ½')
                result['recommendations'].append('æ›´æ–°è·¯ç”±å™¨å›ºä»¶åˆ°æœ€æ–°ç‰ˆæœ¬')
                
            # æ£€æµ‹Reaveræ¼æ´ï¼ˆåŸºäºèŠ¯ç‰‡å‚å•†ï¼‰
            elif any(chip in vendor for chip in self.WPS_VULNERABLE_VENDORS['reaver']):
                result['vulnerable'] = True
                result['vulnerability_type'] = 'WPS PINæš´åŠ›ç ´è§£'
                result['severity'] = 'HIGH'
                result['exploit_time'] = '< 24å°æ—¶'
                result['cvss_score'] = 7.5
                result['recommendations'].append('ç¦ç”¨WPSæˆ–å¯ç”¨WPSé”å®š')
                
            else:
                # WPSå¯ç”¨ä½†æ— å·²çŸ¥æ¼æ´
                result['severity'] = 'MEDIUM'
                result['exploit_time'] = 'å¯èƒ½æ•°å¤©'
                result['cvss_score'] = 5.0
                result['recommendations'].append('å»ºè®®ç¦ç”¨WPSä»¥æé«˜å®‰å…¨æ€§')
        
        return result
    
    def detect_evil_twin(self, networks: List[Dict[str, Any]]) -> List[Dict[str, Any]]:
        """
        æ£€æµ‹Evil Twinæ”»å‡»ï¼ˆé’“é±¼çƒ­ç‚¹ï¼‰
        
        Args:
            networks: ç½‘ç»œåˆ—è¡¨
            
        Returns:
            å¯ç–‘Evil Twinåˆ—è¡¨
        """
        evil_twins = []
        
        # æŒ‰SSIDåˆ†ç»„
        ssid_groups = defaultdict(list)
        for net in networks:
            ssid = net.get('ssid', '')
            if ssid:  # å¿½ç•¥éšè—SSID
                ssid_groups[ssid].append(net)
        
        # æ£€æµ‹æ¯ä¸ªSSIDç»„
        for ssid, aps in ssid_groups.items():
            if len(aps) > 1:
                # ç›¸åŒSSIDä½†å¤šä¸ªBSSID - å¯èƒ½æ˜¯Mesh/ä¸­ç»§æˆ–Evil Twin
                suspicious_aps = self._analyze_ap_group(ssid, aps)
                evil_twins.extend(suspicious_aps)
        
        return evil_twins
    
    def detect_ssid_spoofing(self, networks: List[Dict[str, Any]]) -> List[Dict[str, Any]]:
        """
        æ£€æµ‹SSIDæ¬ºéª—ï¼ˆç›¸ä¼¼SSIDï¼‰
        
        Args:
            networks: ç½‘ç»œåˆ—è¡¨
            
        Returns:
            å¯ç–‘æ¬ºéª—åˆ—è¡¨
        """
        spoofing_cases = []
        
        for i, net1 in enumerate(networks):
            ssid1 = net1.get('ssid', '')
            if not ssid1 or len(ssid1) < 3:
                continue
                
            for net2 in networks[i+1:]:
                ssid2 = net2.get('ssid', '')
                if not ssid2 or len(ssid2) < 3:
                    continue
                
                # è®¡ç®—ç›¸ä¼¼åº¦
                similarity = self._calculate_similarity(ssid1, ssid2)
                
                if 0.7 < similarity < 1.0:  # 70%-99%ç›¸ä¼¼ä½†ä¸å®Œå…¨ç›¸åŒ
                    spoofing_cases.append({
                        'ssid1': ssid1,
                        'bssid1': net1.get('bssid', 'N/A'),
                        'ssid2': ssid2,
                        'bssid2': net2.get('bssid', 'N/A'),
                        'similarity': round(similarity * 100, 1),
                        'warning': f"å¯èƒ½æ¬ºéª—: '{ssid2}' ä¼ªè£…æˆ '{ssid1}'",
                        'severity': 'HIGH' if similarity > 0.85 else 'MEDIUM'
                    })
        
        return spoofing_cases
    
    def detect_suspicious_aps(self, network: Dict[str, Any]) -> Optional[Dict[str, Any]]:
        """
        æ£€æµ‹å¯ç–‘AP
        
        Args:
            network: ç½‘ç»œä¿¡æ¯
            
        Returns:
            å¯ç–‘ç‰¹å¾ï¼ˆå¦‚æœæœ‰ï¼‰
        """
        ssid = network.get('ssid', '').lower()
        bssid = network.get('bssid', '')
        signal = network.get('signal', -100)
        # ä¿®å¤ï¼šç¡®ä¿signalæ˜¯æ•´æ•°ç±»å‹
        if isinstance(signal, str):
            match = re.search(r'-?\d+', signal)
            signal = int(match.group()) if match else -100
        
        # 1. æ£€æµ‹é»˜è®¤SSID
        if ssid in self.DEFAULT_SSIDS:
            return {
                'type': 'ä½¿ç”¨é»˜è®¤SSID',
                'severity': 'MEDIUM',
                'description': 'è·¯ç”±å™¨ä½¿ç”¨é»˜è®¤SSIDï¼Œå¯èƒ½æœªæ­£ç¡®é…ç½®',
                'recommendation': 'ä¿®æ”¹ä¸ºè‡ªå®šä¹‰SSIDå¹¶è®¾ç½®å¼ºå¯†ç '
            }
        
        # 2. æ£€æµ‹éšè—SSID
        if not ssid or ssid == '':
            return {
                'type': 'éšè—SSID',
                'severity': 'LOW',
                'description': 'SSIDè¢«éšè—ï¼ˆä¼ªè£…å®‰å…¨æªæ–½ï¼‰',
                'recommendation': 'éšè—SSIDæ— æ³•çœŸæ­£æé«˜å®‰å…¨æ€§'
            }
        
        # 3. æ£€æµ‹å¼‚å¸¸å¼ºä¿¡å·ï¼ˆå¯èƒ½æ˜¯è¿‘è·ç¦»éƒ¨ç½²çš„æ¶æ„APï¼‰
        if signal > -30:
            return {
                'type': 'ä¿¡å·å¼‚å¸¸å¼º',
                'severity': 'HIGH',
                'description': f'ä¿¡å·å¼ºåº¦{signal}dBmå¼‚å¸¸å¼ºï¼Œå¯èƒ½æ˜¯æ¶æ„AP',
                'recommendation': 'æ£€æŸ¥æ˜¯å¦æœ‰æœªçŸ¥è®¾å¤‡åœ¨é™„è¿‘'
            }
        
        # 4. æ£€æµ‹ç‰¹æ®Šå­—ç¬¦SSIDï¼ˆå¯èƒ½æ˜¯æµ‹è¯•/æ”»å‡»å·¥å…·ï¼‰
        if re.search(r'[^\w\s\-_]', ssid):
            return {
                'type': 'SSIDåŒ…å«ç‰¹æ®Šå­—ç¬¦',
                'severity': 'LOW',
                'description': 'SSIDåŒ…å«éå¸¸è§„å­—ç¬¦',
                'recommendation': 'è°¨æ…è¿æ¥'
            }
        
        return None
    
    def analyze_encryption_detail(self, network: Dict[str, Any]) -> Dict[str, Any]:
        """
        è¯¦ç»†åˆ†æåŠ å¯†é…ç½®ï¼ˆå¢å¼ºWiFi 6E/7åè®®æ”¯æŒ + PMF/KRACKæ£€æµ‹ï¼‰
        
        Args:
            network: ç½‘ç»œä¿¡æ¯
            
        Returns:
            åŠ å¯†è¯¦ç»†åˆ†æ
        """
        auth = network.get('authentication', 'N/A').upper()
        wifi_standard = network.get('wifi_standard', 'N/A')
        
        result = {
            'protocol': None,
            'cipher': None,
            'key_management': None,
            'security_level': 0,  # 0-100
            'vulnerabilities': [],
            'recommendations': [],
            'wifi_protocol': wifi_standard,  # WiFiåè®®ä¿¡æ¯
            'pmf_status': 'UNKNOWN',  # æ–°å¢ï¼šPMFçŠ¶æ€
            'krack_vulnerable': False,  # æ–°å¢ï¼šKRACKæ¼æ´
            'compliance': {}  # æ–°å¢ï¼šåˆè§„æ€§ä¿¡æ¯
        }
        
        # è§£æåŠ å¯†åè®®
        if 'WPA3' in auth:
            result['protocol'] = 'WPA3'
            result['security_level'] = 100
            result['cipher'] = 'AES-GCMP-256' if 'Enterprise' in auth else 'AES-GCMP-128'
            result['key_management'] = 'SAE' if 'PSK' in auth or 'Personal' in auth else 'WPA3-Enterprise'
            result['pmf_status'] = 'REQUIRED'  # WPA3å¼ºåˆ¶è¦æ±‚PMF
            result['krack_vulnerable'] = False  # WPA3ä¸å—KRACKå½±å“
            result['compliance']['PCI-DSS'] = 'COMPLIANT'
            result['compliance']['NIST'] = 'RECOMMENDED'
            
            # WiFi 6E/7åè®®æ£€æŸ¥
            if 'WiFi 6E' in wifi_standard or 'WiFi 7' in wifi_standard:
                result['recommendations'].append('âœ… åŠ å¯†æ–¹å¼ç¬¦åˆWiFi 6E/7æ ‡å‡†')
            
        elif 'WPA2' in auth:
            result['protocol'] = 'WPA2'
            result['krack_vulnerable'] = True  # WPA2å—KRACKå½±å“
            
            # æ£€æµ‹PSK vs Enterprise
            if 'ENTERPRISE' in auth or '802.1X' in auth:
                result['key_management'] = 'WPA2-Enterprise'
                result['security_level'] = 95
                result['pmf_status'] = 'CAPABLE'  # ä¼ä¸šçº§åº”æ”¯æŒPMF
                result['compliance']['PCI-DSS'] = 'COMPLIANT'
            else:
                result['key_management'] = 'WPA2-PSK'
                result['security_level'] = 85
                result['pmf_status'] = 'OPTIONAL'
                result['compliance']['PCI-DSS'] = 'CONDITIONAL'  # éœ€å¼ºå¯†ç 
            
            # WiFi 6E/7åè®®è­¦å‘Š
            if 'WiFi 6E' in wifi_standard or 'WiFi 7' in wifi_standard:
                result['vulnerabilities'].append('âš ï¸ WiFi 6E/7ç½‘ç»œåº”ä½¿ç”¨WPA3åŠ å¯†')
                result['recommendations'].append('ğŸ”´ å¼ºçƒˆå»ºè®®å‡çº§åˆ°WPA3-SAE')
                result['security_level'] = min(result['security_level'], 70)  # é™ä½è¯„åˆ†
            
            # æ£€æµ‹åŠ å¯†ç®—æ³•
            if 'AES' in auth or 'CCMP' in auth:
                result['cipher'] = 'AES-CCMP-128'
            elif 'TKIP' in auth:
                result['cipher'] = 'TKIP'
                result['security_level'] -= 20
                result['vulnerabilities'].append('ğŸ”´ TKIPå·²è¿‡æ—¶ï¼ˆCVE-2008-3826 Beck-Tewsæ”»å‡»ï¼‰')
                result['recommendations'].append('ç«‹å³å‡çº§åˆ°AES-CCMP')
                result['compliance']['PCI-DSS'] = 'NON-COMPLIANT'
            else:
                result['cipher'] = 'AES-CCMP-128'  # WPA2é»˜è®¤
            
            # KRACKæ¼æ´æ£€æµ‹ï¼ˆCVE-2017-13077æ—ï¼‰
            result['vulnerabilities'].append('ğŸ”´ KRACKæ¼æ´ï¼ˆCVE-2017-13077ï¼‰- å¯†é’¥é‡å®‰è£…æ”»å‡»')
            result['vulnerabilities'].append('ğŸŸ¡ PMKIDæ”»å‡»ï¼ˆhashcatç ´è§£ï¼‰')
            result['recommendations'].append('ğŸ”§ æ›´æ–°è·¯ç”±å™¨å›ºä»¶ï¼ˆKRACKè¡¥ä¸ï¼‰')
            result['recommendations'].append('ğŸ”§ å¯ç”¨802.11wç®¡ç†å¸§ä¿æŠ¤ï¼ˆPMFï¼‰')
            result['recommendations'].append('ğŸ”§ æˆ–å‡çº§åˆ°WPA3-SAE')
            
        elif 'WPA' in auth and 'WPA2' not in auth:  # çº¯WPA
            result['protocol'] = 'WPA'
            result['cipher'] = 'TKIP'
            result['key_management'] = 'WPA-PSK'
            result['security_level'] = 30
            result['pmf_status'] = 'NOT_SUPPORTED'
            result['krack_vulnerable'] = True
            result['compliance']['PCI-DSS'] = 'NON-COMPLIANT'
            result['vulnerabilities'].append('ğŸ”´ WPAåè®®å·²å¼ƒç”¨ï¼ˆ2004å¹´ï¼‰')
            result['vulnerabilities'].append('ğŸ”´ TKIPå¯†é’¥æ¢å¤æ”»å‡»')
            result['recommendations'].append('âš ï¸ ç«‹å³å‡çº§åˆ°WPA2-AESæˆ–WPA3')
            
        elif 'WEP' in auth:
            result['protocol'] = 'WEP'
            result['cipher'] = 'RC4'
            result['key_management'] = 'WEP-40/104'
            result['security_level'] = 5
            result['pmf_status'] = 'NOT_SUPPORTED'
            result['krack_vulnerable'] = False  # WEPæœ‰æ›´ä¸¥é‡çš„æ¼æ´
            result['compliance']['PCI-DSS'] = 'PROHIBITED'  # PCI-DSSç¦æ­¢WEP
            result['vulnerabilities'].append('ğŸ”´ WEPææ˜“ç ´è§£ï¼ˆ<5åˆ†é’Ÿï¼‰')
            result['vulnerabilities'].append('ğŸ”´ FMSæ”»å‡»ï¼ˆCVE-2001-0534ï¼‰')
            result['vulnerabilities'].append('ğŸ”´ PTWæ”»å‡»ï¼ˆCVE-2007-6316ï¼‰')
            result['vulnerabilities'].append('ğŸ”´ RC4å¯†é’¥æµå¤ç”¨')
            result['recommendations'].append('âš ï¸ ç´§æ€¥ï¼šç«‹å³å‡çº§åˆ°WPA2/WPA3')
            
        else:  # Open
            result['protocol'] = 'Open'
            result['security_level'] = 0
            result['pmf_status'] = 'NOT_APPLICABLE'
            result['krack_vulnerable'] = False
            result['compliance']['PCI-DSS'] = 'NON-COMPLIANT'
            result['vulnerabilities'].append('ğŸ”´ æ— åŠ å¯†ï¼Œæ•°æ®å®Œå…¨æš´éœ²')
            result['vulnerabilities'].append('ğŸ”´ ä¸­é—´äººæ”»å‡»ï¼ˆMITMï¼‰')
            result['vulnerabilities'].append('ğŸ”´ æ•°æ®çªƒå¬')
            result['recommendations'].append('âš ï¸ ç«‹å³è®¾ç½®WPA2-AESæˆ–WPA3åŠ å¯†')
        
        return result
    
    def check_pmf_support(self, network: Dict[str, Any]) -> Dict[str, Any]:
        """
        æ£€æµ‹802.11wç®¡ç†å¸§ä¿æŠ¤ï¼ˆPMFï¼‰æ”¯æŒ
        
        Args:
            network: ç½‘ç»œä¿¡æ¯
            
        Returns:
            PMFæ£€æµ‹ç»“æœ
        """
        auth = network.get('authentication', '').upper()
        wifi_standard = network.get('wifi_standard', 'N/A')
        
        result = {
            'pmf_capable': False,      # MFPC: Management Frame Protection Capable
            'pmf_required': False,     # MFPR: Management Frame Protection Required
            'risk_level': 'UNKNOWN',
            'vulnerabilities': [],
            'recommendations': []
        }
        
        # WPA3å¼ºåˆ¶è¦æ±‚PMF
        if 'WPA3' in auth:
            result['pmf_capable'] = True
            result['pmf_required'] = True
            result['risk_level'] = 'LOW'
            result['recommendations'].append('âœ… WPA3å¼ºåˆ¶å¯ç”¨PMFï¼Œé˜²æŠ¤ç®¡ç†å¸§æ”»å‡»')
            return result
        
        # WPA2éœ€è¦æ‰‹åŠ¨å¯ç”¨PMFï¼ˆWindows netshæ— æ³•ç›´æ¥æ£€æµ‹ï¼Œä½¿ç”¨å¯å‘å¼ï¼‰
        if 'WPA2' in auth:
            # WiFi 6/6Eè®¾å¤‡é€šå¸¸æ”¯æŒPMF
            if 'WiFi 6' in wifi_standard or 'WiFi 7' in wifi_standard:
                result['pmf_capable'] = True
                result['pmf_required'] = False  # å¯é€‰
                result['risk_level'] = 'MEDIUM'
                result['recommendations'].append('ğŸŸ¡ å»ºè®®åœ¨è·¯ç”±å™¨ä¸­å¯ç”¨PMFï¼ˆ802.11wï¼‰')
            else:
                result['pmf_capable'] = False
                result['risk_level'] = 'HIGH'
                result['vulnerabilities'].append('ğŸ”´ æœªå¯ç”¨PMF - æ˜“å—ç®¡ç†å¸§æ”»å‡»')
                result['vulnerabilities'].append('ğŸ”´ Deauthenticationæ”»å‡»ï¼ˆæ–­å¼€è¿æ¥ï¼‰')
                result['vulnerabilities'].append('ğŸ”´ Disassociationæ”»å‡»ï¼ˆæ‹’ç»æœåŠ¡ï¼‰')
                result['recommendations'].append('âš ï¸ å‡çº§åˆ°æ”¯æŒPMFçš„è·¯ç”±å™¨')
                result['recommendations'].append('âš ï¸ æˆ–å‡çº§åˆ°WPA3ï¼ˆå¼ºåˆ¶PMFï¼‰')
        else:
            result['risk_level'] = 'CRITICAL'
            result['vulnerabilities'].append('ğŸ”´ ä¸æ”¯æŒPMFï¼ˆWPA/WEP/Openï¼‰')
        
        return result
    
    def check_krack_vulnerability_detailed(self, network: Dict[str, Any]) -> Dict[str, Any]:
        """
        è¯¦ç»†KRACKæ¼æ´æ£€æµ‹ï¼ˆCVE-2017-13077æ—ï¼‰
        
        Args:
            network: ç½‘ç»œä¿¡æ¯
            
        Returns:
            KRACKæ¼æ´è¯¦ç»†åˆ†æ
        """
        auth = network.get('authentication', '').upper()
        
        result = {
            'vulnerable': False,
            'cve_list': [],
            'severity': 'NONE',
            'cvss_score': 0.0,
            'attack_vectors': [],
            'impact': [],
            'recommendations': []
        }
        
        # WPA3ä¸å—KRACKå½±å“
        if 'WPA3' in auth:
            result['vulnerable'] = False
            result['severity'] = 'NONE'
            result['recommendations'].append('âœ… WPA3å…ç–«KRACKæ”»å‡»')
            return result
        
        # WPA2/WPAå—KRACKå½±å“
        if 'WPA2' in auth or ('WPA' in auth and 'WPA3' not in auth):
            result['vulnerable'] = True
            result['severity'] = 'CRITICAL'
            result['cvss_score'] = 8.1
            
            # KRACKæ”»å‡»æ—CVE
            result['cve_list'] = [
                {
                    'cve_id': 'CVE-2017-13077',
                    'name': 'PTK-TKé‡å®‰è£…æ”»å‡»',
                    'description': 'å››æ¬¡æ¡æ‰‹ä¸­æˆå¯¹å¯†é’¥é‡å®‰è£…',
                    'impact': 'è§£å¯†æ•°æ®åŒ…ã€ä¼ªé€ æ•°æ®åŒ…'
                },
                {
                    'cve_id': 'CVE-2017-13078',
                    'name': 'GTKé‡å®‰è£…æ”»å‡»',
                    'description': 'ç»„å¯†é’¥é‡å®‰è£…',
                    'impact': 'è§£å¯†ç»„æ’­/å¹¿æ’­æµé‡'
                },
                {
                    'cve_id': 'CVE-2017-13079',
                    'name': 'IGTKé‡å®‰è£…æ”»å‡»',
                    'description': 'å®Œæ•´æ€§ç»„å¯†é’¥é‡å®‰è£…',
                    'impact': 'ä¼ªé€ ç®¡ç†å¸§ï¼ˆå¦‚æœæ”¯æŒPMFï¼‰'
                },
                {
                    'cve_id': 'CVE-2017-13080',
                    'name': 'GTKé‡ä¼ æ”»å‡»',
                    'description': 'ç»„å¯†é’¥æ¡æ‰‹é‡ä¼ ',
                    'impact': 'é‡æ”¾ä¿æŠ¤ç»•è¿‡'
                },
                {
                    'cve_id': 'CVE-2017-13082',
                    'name': 'FTæ¡æ‰‹æ”»å‡»',
                    'description': 'å¿«é€ŸBSSè½¬æ¢æ¡æ‰‹',
                    'impact': 'å¯†é’¥é‡å®‰è£…ï¼ˆ802.11rï¼‰'
                }
            ]
            
            result['attack_vectors'] = [
                'ä¸­é—´äººæ”»å‡»ï¼ˆMITMï¼‰',
                'é‡æ”¾æ”»å‡»',
                'æ•°æ®åŒ…è§£å¯†',
                'æ•°æ®åŒ…æ³¨å…¥/ä¼ªé€ ',
                'TCPè¿æ¥åŠ«æŒ'
            ]
            
            result['impact'] = [
                'ğŸ”´ HTTPæµé‡å®Œå…¨æš´éœ²',
                'ğŸ”´ æ•æ„Ÿä¿¡æ¯æ³„éœ²ï¼ˆå¯†ç ã€Cookieï¼‰',
                'ğŸ”´ ä¼šè¯åŠ«æŒ',
                'ğŸŸ¡ HTTPSæµé‡å—SSL/TLSä¿æŠ¤ï¼ˆä½†å¯é™çº§æ”»å‡»ï¼‰'
            ]
            
            result['recommendations'] = [
                'ğŸ”§ ç«‹å³æ›´æ–°è·¯ç”±å™¨å›ºä»¶ï¼ˆKRACKè¡¥ä¸ï¼‰',
                'ğŸ”§ æ›´æ–°æ‰€æœ‰WiFiè®¾å¤‡é©±åŠ¨ç¨‹åº',
                'ğŸ”§ å¯ç”¨802.11wç®¡ç†å¸§ä¿æŠ¤ï¼ˆPMFï¼‰',
                'ğŸ”§ å‡çº§åˆ°WPA3-SAEï¼ˆæ ¹æœ¬è§£å†³æ–¹æ¡ˆï¼‰',
                'ğŸ”§ ä½¿ç”¨VPNåŠ å¯†æ‰€æœ‰æµé‡ï¼ˆä¸´æ—¶æªæ–½ï¼‰',
                'âš ï¸ é¿å…åœ¨å…¬å…±WiFiè¿›è¡Œæ•æ„Ÿæ“ä½œ'
            ]
        else:
            # WEP/Openæœ‰æ›´ä¸¥é‡çš„æ¼æ´
            result['vulnerable'] = False
            result['severity'] = 'NONE'
            result['recommendations'].append('âš ï¸ è¯¥ç½‘ç»œæœ‰æ¯”KRACKæ›´ä¸¥é‡çš„å®‰å…¨é—®é¢˜')
        
        return result
    
    # ===== è¾…åŠ©æ–¹æ³• =====
    
    def _get_vendor_from_bssid(self, bssid: str) -> str:
        """ä»BSSIDè·å–å‚å•†"""
        if not bssid or len(bssid) < 8:
            return 'Unknown'
        
        # MACåœ°å€å‰6ä½ï¼ˆOUIï¼‰å¯¹åº”å‚å•†
        oui = bssid[:8].upper().replace(':', '')
        
        # ç®€åŒ–å‚å•†æ•°æ®åº“ï¼ˆä»…å¸¸è§å‚å•†ï¼‰
        oui_db = {
            '001839': 'TP-Link',
            '1062EB': 'TP-Link',
            'C46E1F': 'TP-Link',
            '0C805C': 'D-Link',
            '0018E7': 'D-Link',
            'C05627': 'Netgear',
            '2C3033': 'Netgear',
            '68A3C4': 'Linksys',
            'C05826': 'Linksys',
            'EC1A59': 'Belkin',
            '001CDF': 'Belkin',
            '04BF6D': 'ASUS',
            '08606E': 'ASUS',
            'E84E06': 'Huawei',
            '00259E': 'Huawei',
            '6C198F': 'ZTE',
            '509EA7': 'ZTE',
            'C83A35': 'Tenda',
            '00B00C': 'Tenda'
        }
        
        return oui_db.get(oui[:6], 'Unknown')
    
    def _is_wps_likely_enabled(self, network: Dict[str, Any], vendor: str) -> bool:
        """
        å¯å‘å¼åˆ¤æ–­WPSæ˜¯å¦å¯ç”¨
        
        è§„åˆ™ï¼š
        1. å®¶ç”¨è·¯ç”±å™¨å“ç‰Œé»˜è®¤å¯ç”¨WPS
        2. WPA2åŠ å¯†çš„å®¶ç”¨ç½‘ç»œé€šå¸¸å¯ç”¨WPS
        3. ä¼ä¸šç½‘ç»œï¼ˆWPA2-Enterpriseï¼‰é€šå¸¸ç¦ç”¨WPS
        """
        auth = network.get('authentication', '').upper()
        
        # ä¼ä¸šç½‘ç»œé€šå¸¸ç¦ç”¨WPS
        if 'ENTERPRISE' in auth or '802.1X' in auth:
            return False
        
        # å¼€æ”¾ç½‘ç»œå’ŒWEPä¸æ”¯æŒWPS
        if 'OPEN' in auth or auth == 'å¼€æ”¾' or 'WEP' in auth:
            return False
        
        # å®¶ç”¨è·¯ç”±å™¨å“ç‰Œ
        home_vendors = {'TP-Link', 'D-Link', 'Netgear', 'Linksys', 
                       'Belkin', 'ASUS', 'Tenda', 'Huawei', 'ZTE'}
        
        if vendor in home_vendors:
            return True
        
        # WPA/WPA2çš„é»˜è®¤å‡è®¾
        if 'WPA' in auth:
            return True
        
        return False
    
    def _analyze_ap_group(self, ssid: str, aps: List[Dict[str, Any]]) -> List[Dict[str, Any]]:
        """åˆ†æç›¸åŒSSIDçš„APç»„ï¼Œæ£€æµ‹Evil Twin"""
        suspicious = []
        
        # æ£€æŸ¥æ˜¯å¦åœ¨ç™½åå•ï¼ˆåˆæ³•çš„Mesh/ä¸­ç»§ç³»ç»Ÿï¼‰
        known_bssids = self.known_aps.get(ssid, [])
        
        # æå–ç‰¹å¾
        vendors = [self._get_vendor_from_bssid(ap.get('bssid', '')) for ap in aps]
        auths = [ap.get('authentication', '') for ap in aps]
        
        # ä¿®å¤ï¼šç¡®ä¿channelæ˜¯æ•´æ•°ç±»å‹ï¼Œå¤„ç†å­—ç¬¦ä¸²æ ¼å¼ï¼ˆå¦‚"6", "11", "N/A"ï¼‰
        channels = []
        for ap in aps:
            channel_val = ap.get('channel', 0)
            if isinstance(channel_val, str):
                # å°è¯•æå–æ•°å­—ï¼Œå¦‚æœå¤±è´¥åˆ™ä½¿ç”¨0
                try:
                    channel_val = int(re.search(r'\d+', channel_val).group()) if re.search(r'\d+', channel_val) else 0
                except (ValueError, AttributeError):
                    channel_val = 0
            elif not isinstance(channel_val, int):
                channel_val = 0
            channels.append(channel_val)
        
        # ä¿®å¤ï¼šç¡®ä¿signalæ˜¯æ•´æ•°ç±»å‹ï¼Œå¤„ç†å­—ç¬¦ä¸²æ ¼å¼ï¼ˆå¦‚"-50dBm"ï¼‰
        signals = []
        for ap in aps:
            signal_val = ap.get('signal', -100)
            if isinstance(signal_val, str):
                # ç§»é™¤"dBm"ç­‰åç¼€ï¼Œæå–æ•°å­—
                signal_val = int(re.search(r'-?\d+', signal_val).group())
            signals.append(signal_val)
        
        for i, ap in enumerate(aps):
            bssid = ap.get('bssid', '')
            
            # å·²çŸ¥APï¼Œè·³è¿‡
            if bssid in known_bssids:
                continue
            
            confidence = 0
            reasons = []
            
            # 1. MACå‚å•†ä¸ä¸€è‡´ï¼ˆä¸åŒå“ç‰Œè·¯ç”±å™¨ä½¿ç”¨ç›¸åŒSSIDï¼‰
            if len(set(vendors)) > 1:
                confidence += 30
                reasons.append(f'MACå‚å•†ä¸ä¸€è‡´ï¼š{vendors[i]} vs {set(vendors)-{vendors[i]}}')
            
            # 2. åŠ å¯†é…ç½®ä¸ä¸€è‡´
            if len(set(auths)) > 1:
                confidence += 25
                reasons.append(f'åŠ å¯†æ–¹å¼ä¸ä¸€è‡´')
            
            # 3. ä¿¡å·å¼‚å¸¸å¼ºï¼ˆå¯èƒ½åœ¨é™„è¿‘æ¶æ„éƒ¨ç½²ï¼‰
            if signals[i] > -30:
                confidence += 20
                reasons.append(f'ä¿¡å·å¼‚å¸¸å¼ºï¼ˆ{signals[i]}dBmï¼‰')
            
            # 4. ä¿¡é“åˆ†æ•£ï¼ˆåˆæ³•Meshé€šå¸¸ä½¿ç”¨ç›¸é‚»ä¿¡é“ï¼‰
            if channels and max(channels) - min(channels) > 6:
                confidence += 15
                reasons.append('ä¿¡é“åˆ†å¸ƒå¼‚å¸¸')
            
            # 5. å¦‚æœå…¶ä»–APä¿¡å·å¼±ï¼Œæ­¤APä¿¡å·å¼ºï¼ˆå…¸å‹Evil Twinç‰¹å¾ï¼‰
            avg_signal = sum(s for j, s in enumerate(signals) if j != i) / max(len(signals)-1, 1)
            if signals[i] - avg_signal > 20:
                confidence += 10
                reasons.append('ä¿¡å·å¼ºåº¦å¼‚å¸¸çªå‡º')
            
            if confidence >= 30:  # 30%ä»¥ä¸Šç½®ä¿¡åº¦
                suspicious.append({
                    'ssid': ssid,
                    'bssid': bssid,
                    'type': 'Evil Twinï¼ˆé’“é±¼çƒ­ç‚¹ï¼‰',
                    'confidence': min(confidence, 100),
                    'signal': f"{signals[i]}dBm",
                    'reasons': reasons,
                    'severity': 'CRITICAL' if confidence >= 60 else 'HIGH',
                    'recommendation': 'ä¸è¦è¿æ¥æ­¤ç½‘ç»œï¼å¯èƒ½æ˜¯æ¶æ„é’“é±¼çƒ­ç‚¹'
                })
        
        return suspicious
    
    def _calculate_similarity(self, s1: str, s2: str) -> float:
        """
        è®¡ç®—å­—ç¬¦ä¸²ç›¸ä¼¼åº¦ï¼ˆLevenshteinè·ç¦»ï¼‰
        
        Returns:
            ç›¸ä¼¼åº¦ 0.0-1.0
        """
        if s1 == s2:
            return 1.0
        
        len1, len2 = len(s1), len(s2)
        if len1 == 0 or len2 == 0:
            return 0.0
        
        # åŠ¨æ€è§„åˆ’è®¡ç®—ç¼–è¾‘è·ç¦»
        dp = [[0] * (len2 + 1) for _ in range(len1 + 1)]
        
        for i in range(len1 + 1):
            dp[i][0] = i
        for j in range(len2 + 1):
            dp[0][j] = j
        
        for i in range(1, len1 + 1):
            for j in range(1, len2 + 1):
                if s1[i-1].lower() == s2[j-1].lower():
                    dp[i][j] = dp[i-1][j-1]
                else:
                    dp[i][j] = min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + 1
        
        distance = dp[len1][len2]
        max_len = max(len1, len2)
        
        return 1.0 - (distance / max_len)
    
    def add_known_ap(self, ssid: str, bssid: str):
        """æ·»åŠ å·²çŸ¥APåˆ°ç™½åå•"""
        if ssid not in self.known_aps:
            self.known_aps[ssid] = []
        if bssid not in self.known_aps[ssid]:
            self.known_aps[ssid].append(bssid)
