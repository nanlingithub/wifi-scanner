"""
WiFi漏洞检测模块
功能：WPS漏洞、Evil Twin、加密分析
版本：V2.0 Enhanced (集成CVE数据库)
"""

import re
from collections import defaultdict
from typing import Dict, List, Any, Optional

# 导入WPS CVE数据库
try:
    from .wps_cve_database import WPSCVEDatabase
    HAS_CVE_DB = True
except ImportError:
    HAS_CVE_DB = False


class VulnerabilityDetector:
    """WiFi漏洞检测器"""
    
    # WPS漏洞厂商数据库（基于公开漏洞报告）
    WPS_VULNERABLE_VENDORS = {
        # PixieDust漏洞（CVE-2017-16898）
        'pixiedust': {
            'D-Link', 'TP-Link', 'Netgear', 'Linksys', 'Belkin',
            'ZyXEL', 'ASUS', 'Huawei', 'ZTE', 'Tenda'
        },
        # Reaver已知漏洞
        'reaver': {
            'Broadcom', 'Ralink', 'Realtek', 'Atheros'
        }
    }
    
    # 默认SSID列表（可疑AP）
    DEFAULT_SSIDS = {
        'tp-link', 'netgear', 'linksys', 'dlink', 'd-link',
        'asus', 'belkin', 'zyxel', 'huawei', 'zte', 'tenda',
        'default', 'wireless', 'wifi', 'network', 'home',
        'router', 'modem', 'internet', 'speedtouch'
    }
    
    def __init__(self):
        self.known_aps = {}  # 白名单AP数据库 {ssid: [bssid1, bssid2, ...]}
        # 初始化WPS CVE数据库
        if HAS_CVE_DB:
            self.wps_cve_db = WPSCVEDatabase()
        else:
            self.wps_cve_db = None
        
    def check_wps_vulnerability(self, network: Dict[str, Any]) -> Dict[str, Any]:
        """
        检测WPS漏洞（增强版 - 集成CVE数据库）
        
        Args:
            network: 网络信息字典
            
        Returns:
            漏洞检测结果
        """
        result = {
            'wps_enabled': False,
            'vulnerable': False,
            'vulnerability_type': None,
            'severity': 'LOW',
            'exploit_time': None,
            'recommendations': [],
            'cve_list': [],  # 新增：相关CVE列表
            'cvss_score': 0.0  # 新增：CVSS评分
        }
        
        # 1. 检测WPS是否启用（基于启发式规则）
        auth = network.get('authentication', '').upper()
        vendor = self._get_vendor_from_bssid(network.get('bssid', ''))
        
        # Windows netsh无法直接检测WPS，使用启发式推断
        # 规则：大部分家用路由器默认启用WPS
        wps_likely = self._is_wps_likely_enabled(network, vendor)
        
        if wps_likely:
            result['wps_enabled'] = True
            
            # 2. 使用CVE数据库检测（优先）
            if self.wps_cve_db:
                cve_vulns = self.wps_cve_db.get_vulnerabilities_by_vendor(vendor)
                
                if cve_vulns:
                    # 使用最严重的漏洞
                    most_severe = cve_vulns[0]
                    result['vulnerable'] = True
                    result['vulnerability_type'] = f"{most_severe['name']} ({most_severe['cve_id']})"
                    result['severity'] = most_severe['severity']
                    result['exploit_time'] = most_severe['exploit_time']
                    result['cvss_score'] = most_severe['cvss_score']
                    result['recommendations'] = most_severe['recommendations']
                    
                    # 添加所有相关CVE
                    result['cve_list'] = [
                        {
                            'cve_id': v['cve_id'],
                            'name': v['name'],
                            'severity': v['severity'],
                            'cvss_score': v['cvss_score'],
                            'patch_available': v['patch_available']
                        }
                        for v in cve_vulns[:5]  # 最多5个
                    ]
                    
                    return result
            
            # 3. 回退到原有检测逻辑（如果没有CVE数据库）
            # 检测PixieDust漏洞
            if vendor in self.WPS_VULNERABLE_VENDORS['pixiedust']:
                result['vulnerable'] = True
                result['vulnerability_type'] = 'PixieDust (CVE-2017-16898)'
                result['severity'] = 'CRITICAL'
                result['exploit_time'] = '< 5分钟'
                result['cvss_score'] = 9.8
                result['recommendations'].append('立即禁用WPS功能')
                result['recommendations'].append('更新路由器固件到最新版本')
                
            # 检测Reaver漏洞（基于芯片厂商）
            elif any(chip in vendor for chip in self.WPS_VULNERABLE_VENDORS['reaver']):
                result['vulnerable'] = True
                result['vulnerability_type'] = 'WPS PIN暴力破解'
                result['severity'] = 'HIGH'
                result['exploit_time'] = '< 24小时'
                result['cvss_score'] = 7.5
                result['recommendations'].append('禁用WPS或启用WPS锁定')
                
            else:
                # WPS启用但无已知漏洞
                result['severity'] = 'MEDIUM'
                result['exploit_time'] = '可能数天'
                result['cvss_score'] = 5.0
                result['recommendations'].append('建议禁用WPS以提高安全性')
        
        return result
    
    def detect_evil_twin(self, networks: List[Dict[str, Any]]) -> List[Dict[str, Any]]:
        """
        检测Evil Twin攻击（钓鱼热点）
        
        Args:
            networks: 网络列表
            
        Returns:
            可疑Evil Twin列表
        """
        evil_twins = []
        
        # 按SSID分组
        ssid_groups = defaultdict(list)
        for net in networks:
            ssid = net.get('ssid', '')
            if ssid:  # 忽略隐藏SSID
                ssid_groups[ssid].append(net)
        
        # 检测每个SSID组
        for ssid, aps in ssid_groups.items():
            if len(aps) > 1:
                # 相同SSID但多个BSSID - 可能是Mesh/中继或Evil Twin
                suspicious_aps = self._analyze_ap_group(ssid, aps)
                evil_twins.extend(suspicious_aps)
        
        return evil_twins
    
    def detect_ssid_spoofing(self, networks: List[Dict[str, Any]]) -> List[Dict[str, Any]]:
        """
        检测SSID欺骗（相似SSID）
        
        Args:
            networks: 网络列表
            
        Returns:
            可疑欺骗列表
        """
        spoofing_cases = []
        
        for i, net1 in enumerate(networks):
            ssid1 = net1.get('ssid', '')
            if not ssid1 or len(ssid1) < 3:
                continue
                
            for net2 in networks[i+1:]:
                ssid2 = net2.get('ssid', '')
                if not ssid2 or len(ssid2) < 3:
                    continue
                
                # 计算相似度
                similarity = self._calculate_similarity(ssid1, ssid2)
                
                if 0.7 < similarity < 1.0:  # 70%-99%相似但不完全相同
                    spoofing_cases.append({
                        'ssid1': ssid1,
                        'bssid1': net1.get('bssid', 'N/A'),
                        'ssid2': ssid2,
                        'bssid2': net2.get('bssid', 'N/A'),
                        'similarity': round(similarity * 100, 1),
                        'warning': f"可能欺骗: '{ssid2}' 伪装成 '{ssid1}'",
                        'severity': 'HIGH' if similarity > 0.85 else 'MEDIUM'
                    })
        
        return spoofing_cases
    
    def detect_suspicious_aps(self, network: Dict[str, Any]) -> Optional[Dict[str, Any]]:
        """
        检测可疑AP
        
        Args:
            network: 网络信息
            
        Returns:
            可疑特征（如果有）
        """
        ssid = network.get('ssid', '').lower()
        bssid = network.get('bssid', '')
        signal = network.get('signal', -100)
        # 修复：确保signal是整数类型
        if isinstance(signal, str):
            match = re.search(r'-?\d+', signal)
            signal = int(match.group()) if match else -100
        
        # 1. 检测默认SSID
        if ssid in self.DEFAULT_SSIDS:
            return {
                'type': '使用默认SSID',
                'severity': 'MEDIUM',
                'description': '路由器使用默认SSID，可能未正确配置',
                'recommendation': '修改为自定义SSID并设置强密码'
            }
        
        # 2. 检测隐藏SSID
        if not ssid or ssid == '':
            return {
                'type': '隐藏SSID',
                'severity': 'LOW',
                'description': 'SSID被隐藏（伪装安全措施）',
                'recommendation': '隐藏SSID无法真正提高安全性'
            }
        
        # 3. 检测异常强信号（可能是近距离部署的恶意AP）
        if signal > -30:
            return {
                'type': '信号异常强',
                'severity': 'HIGH',
                'description': f'信号强度{signal}dBm异常强，可能是恶意AP',
                'recommendation': '检查是否有未知设备在附近'
            }
        
        # 4. 检测特殊字符SSID（可能是测试/攻击工具）
        if re.search(r'[^\w\s\-_]', ssid):
            return {
                'type': 'SSID包含特殊字符',
                'severity': 'LOW',
                'description': 'SSID包含非常规字符',
                'recommendation': '谨慎连接'
            }
        
        return None
    
    def analyze_encryption_detail(self, network: Dict[str, Any]) -> Dict[str, Any]:
        """
        详细分析加密配置（增强WiFi 6E/7协议支持）
        
        Args:
            network: 网络信息
            
        Returns:
            加密详细分析
        """
        auth = network.get('authentication', 'N/A').upper()
        wifi_standard = network.get('wifi_standard', 'N/A')
        
        result = {
            'protocol': None,
            'cipher': None,
            'key_management': None,
            'security_level': 0,  # 0-100
            'vulnerabilities': [],
            'recommendations': [],
            'wifi_protocol': wifi_standard  # 新增：WiFi协议信息
        }
        
        # 解析加密协议
        if 'WPA3' in auth:
            result['protocol'] = 'WPA3'
            result['security_level'] = 100
            result['cipher'] = 'AES-GCMP'
            result['key_management'] = 'SAE'
            
            # WiFi 6E/7协议检查
            if 'WiFi 6E' in wifi_standard or 'WiFi 7' in wifi_standard:
                result['recommendations'].append('加密方式符合WiFi 6E/7标准')
            
        elif 'WPA2' in auth:
            result['protocol'] = 'WPA2'
            
            # 检测PSK vs Enterprise
            if 'ENTERPRISE' in auth or '802.1X' in auth:
                result['key_management'] = 'WPA2-Enterprise'
                result['security_level'] = 95
            else:
                result['key_management'] = 'WPA2-PSK'
                result['security_level'] = 85
            
            # WiFi 6E/7协议警告
            if 'WiFi 6E' in wifi_standard or 'WiFi 7' in wifi_standard:
                result['vulnerabilities'].append('WiFi 6E/7网络应使用WPA3加密')
                result['recommendations'].append('强烈建议升级到WPA3')
                result['security_level'] = min(result['security_level'], 70)  # 降低评分
            
            # 检测加密算法
            if 'AES' in auth or 'CCMP' in auth:
                result['cipher'] = 'AES-CCMP'
            elif 'TKIP' in auth:
                result['cipher'] = 'TKIP'
                result['security_level'] -= 15
                result['vulnerabilities'].append('TKIP已过时，存在安全漏洞')
                result['recommendations'].append('升级到AES-CCMP')
            else:
                result['cipher'] = 'Unknown'
            
            # KRACK漏洞提示
            result['vulnerabilities'].append('可能受KRACK攻击影响')
            result['recommendations'].append('更新路由器固件')
            result['recommendations'].append('启用802.11w管理帧保护')
            
        elif 'WPA' in auth:
            result['protocol'] = 'WPA'
            result['cipher'] = 'TKIP'
            result['key_management'] = 'WPA-PSK'
            result['security_level'] = 40
            result['vulnerabilities'].append('WPA协议存在已知漏洞')
            result['recommendations'].append('升级到WPA2或WPA3')
            
        elif 'WEP' in auth:
            result['protocol'] = 'WEP'
            result['cipher'] = 'RC4'
            result['security_level'] = 10
            result['vulnerabilities'].append('WEP极易被破解（数分钟内）')
            result['recommendations'].append('立即升级到WPA2/WPA3')
            
        else:  # Open
            result['protocol'] = 'Open'
            result['security_level'] = 0
            result['vulnerabilities'].append('无加密，数据完全暴露')
            result['recommendations'].append('立即设置WPA2/WPA3加密')
        
        return result
    
    # ===== 辅助方法 =====
    
    def _get_vendor_from_bssid(self, bssid: str) -> str:
        """从BSSID获取厂商"""
        if not bssid or len(bssid) < 8:
            return 'Unknown'
        
        # MAC地址前6位（OUI）对应厂商
        oui = bssid[:8].upper().replace(':', '')
        
        # 简化厂商数据库（仅常见厂商）
        oui_db = {
            '001839': 'TP-Link',
            '1062EB': 'TP-Link',
            'C46E1F': 'TP-Link',
            '0C805C': 'D-Link',
            '0018E7': 'D-Link',
            'C05627': 'Netgear',
            '2C3033': 'Netgear',
            '68A3C4': 'Linksys',
            'C05826': 'Linksys',
            'EC1A59': 'Belkin',
            '001CDF': 'Belkin',
            '04BF6D': 'ASUS',
            '08606E': 'ASUS',
            'E84E06': 'Huawei',
            '00259E': 'Huawei',
            '6C198F': 'ZTE',
            '509EA7': 'ZTE',
            'C83A35': 'Tenda',
            '00B00C': 'Tenda'
        }
        
        return oui_db.get(oui[:6], 'Unknown')
    
    def _is_wps_likely_enabled(self, network: Dict[str, Any], vendor: str) -> bool:
        """
        启发式判断WPS是否启用
        
        规则：
        1. 家用路由器品牌默认启用WPS
        2. WPA2加密的家用网络通常启用WPS
        3. 企业网络（WPA2-Enterprise）通常禁用WPS
        """
        auth = network.get('authentication', '').upper()
        
        # 企业网络通常禁用WPS
        if 'ENTERPRISE' in auth or '802.1X' in auth:
            return False
        
        # 开放网络和WEP不支持WPS
        if 'OPEN' in auth or auth == '开放' or 'WEP' in auth:
            return False
        
        # 家用路由器品牌
        home_vendors = {'TP-Link', 'D-Link', 'Netgear', 'Linksys', 
                       'Belkin', 'ASUS', 'Tenda', 'Huawei', 'ZTE'}
        
        if vendor in home_vendors:
            return True
        
        # WPA/WPA2的默认假设
        if 'WPA' in auth:
            return True
        
        return False
    
    def _analyze_ap_group(self, ssid: str, aps: List[Dict[str, Any]]) -> List[Dict[str, Any]]:
        """分析相同SSID的AP组，检测Evil Twin"""
        suspicious = []
        
        # 检查是否在白名单（合法的Mesh/中继系统）
        known_bssids = self.known_aps.get(ssid, [])
        
        # 提取特征
        vendors = [self._get_vendor_from_bssid(ap.get('bssid', '')) for ap in aps]
        auths = [ap.get('authentication', '') for ap in aps]
        
        # 修复：确保channel是整数类型，处理字符串格式（如"6", "11", "N/A"）
        channels = []
        for ap in aps:
            channel_val = ap.get('channel', 0)
            if isinstance(channel_val, str):
                # 尝试提取数字，如果失败则使用0
                try:
                    channel_val = int(re.search(r'\d+', channel_val).group()) if re.search(r'\d+', channel_val) else 0
                except (ValueError, AttributeError):
                    channel_val = 0
            elif not isinstance(channel_val, int):
                channel_val = 0
            channels.append(channel_val)
        
        # 修复：确保signal是整数类型，处理字符串格式（如"-50dBm"）
        signals = []
        for ap in aps:
            signal_val = ap.get('signal', -100)
            if isinstance(signal_val, str):
                # 移除"dBm"等后缀，提取数字
                signal_val = int(re.search(r'-?\d+', signal_val).group())
            signals.append(signal_val)
        
        for i, ap in enumerate(aps):
            bssid = ap.get('bssid', '')
            
            # 已知AP，跳过
            if bssid in known_bssids:
                continue
            
            confidence = 0
            reasons = []
            
            # 1. MAC厂商不一致（不同品牌路由器使用相同SSID）
            if len(set(vendors)) > 1:
                confidence += 30
                reasons.append(f'MAC厂商不一致：{vendors[i]} vs {set(vendors)-{vendors[i]}}')
            
            # 2. 加密配置不一致
            if len(set(auths)) > 1:
                confidence += 25
                reasons.append(f'加密方式不一致')
            
            # 3. 信号异常强（可能在附近恶意部署）
            if signals[i] > -30:
                confidence += 20
                reasons.append(f'信号异常强（{signals[i]}dBm）')
            
            # 4. 信道分散（合法Mesh通常使用相邻信道）
            if channels and max(channels) - min(channels) > 6:
                confidence += 15
                reasons.append('信道分布异常')
            
            # 5. 如果其他AP信号弱，此AP信号强（典型Evil Twin特征）
            avg_signal = sum(s for j, s in enumerate(signals) if j != i) / max(len(signals)-1, 1)
            if signals[i] - avg_signal > 20:
                confidence += 10
                reasons.append('信号强度异常突出')
            
            if confidence >= 30:  # 30%以上置信度
                suspicious.append({
                    'ssid': ssid,
                    'bssid': bssid,
                    'type': 'Evil Twin（钓鱼热点）',
                    'confidence': min(confidence, 100),
                    'signal': f"{signals[i]}dBm",
                    'reasons': reasons,
                    'severity': 'CRITICAL' if confidence >= 60 else 'HIGH',
                    'recommendation': '不要连接此网络！可能是恶意钓鱼热点'
                })
        
        return suspicious
    
    def _calculate_similarity(self, s1: str, s2: str) -> float:
        """
        计算字符串相似度（Levenshtein距离）
        
        Returns:
            相似度 0.0-1.0
        """
        if s1 == s2:
            return 1.0
        
        len1, len2 = len(s1), len(s2)
        if len1 == 0 or len2 == 0:
            return 0.0
        
        # 动态规划计算编辑距离
        dp = [[0] * (len2 + 1) for _ in range(len1 + 1)]
        
        for i in range(len1 + 1):
            dp[i][0] = i
        for j in range(len2 + 1):
            dp[0][j] = j
        
        for i in range(1, len1 + 1):
            for j in range(1, len2 + 1):
                if s1[i-1].lower() == s2[j-1].lower():
                    dp[i][j] = dp[i-1][j-1]
                else:
                    dp[i][j] = min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + 1
        
        distance = dp[len1][len2]
        max_len = max(len1, len2)
        
        return 1.0 - (distance / max_len)
    
    def add_known_ap(self, ssid: str, bssid: str):
        """添加已知AP到白名单"""
        if ssid not in self.known_aps:
            self.known_aps[ssid] = []
        if bssid not in self.known_aps[ssid]:
            self.known_aps[ssid].append(bssid)
